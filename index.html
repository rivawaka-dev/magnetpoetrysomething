<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Multilingual Fridge Poetry</title>
<meta name="description" content="Fridge-poetry magnets with JA + ZH + EN + FR + KO and a slider to mix 1–5 languages.">
<style>html,body{margin:0;padding:0;height:100%;background:#f6f6f6;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}#credits,#howto{position:fixed;background:rgba(255,255,255,.9);border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.08);font-size:12px;color:#111;line-height:1.35;padding:8px 10px;z-index:10}#credits{right:10px;bottom:10px}#howto{left:10px;bottom:10px;max-width:52ch}</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script></head>
<body>
<div id="howto"><b>How to:</b> Drag magnets. Click a word in the center line to swap with the same part-of-speech. Use the buttons top-left to shuffle or reset. Use the slider to choose how many languages are mixed.</div>
<div id="credits">Multilingual Fridge Poetry — JA + ZH + EN + FR + KO</div>
<script>
let magnets, selected=null, offset, scaler, bg;
const STORAGE_KEY="magnets_multi_lang_slider_site_v1_3_safe";
const StorageShim={set:(k,v)=>{try{localStorage.setItem(k,JSON.stringify(v))}catch(e){}},get:(k)=>{try{const v=localStorage.getItem(k);return v?JSON.parse(v):null}catch(e){return null}},remove:(k)=>{try{localStorage.removeItem(k)}catch(e){}}};
const saveMagnets=d=>StorageShim.set(STORAGE_KEY,d), loadMagnets=()=>StorageShim.get(STORAGE_KEY), clearMagnets=()=>StorageShim.remove(STORAGE_KEY);
const UI={shuffle:{x:10,y:10,w:200,h:34,label:"Shuffle Poem"},reset:{x:10,y:54,w:200,h:34,label:"Reset (Scatter)"}};
let langSlider, langLabel, activeLangCount=5;
const SPRING_K=.12,DAMPING=.75,ANG_K=.12,ANG_DAMP=.75,V_EPS=.02,W_EPS=.002;
let dragMoved=false;
const CENTER_BAND=120, CENTER_SOFT_PUSH=.06; let centerBandPx=CENTER_BAND; function recomputeCenterBand(){centerBandPx=CENTER_BAND*(typeof scaler!=="undefined"?scaler:1)}
const LANG_ORDER=["EN","FR","ZH","JA","KO"];
const LEX={EN:{DET:["the","a","an","this","that","my","your","our"],ADJ:["quiet","bright","gentle","damp","old","new","red","blue","soft","cold","warm","shiny","dim"],NOUN:["street","sign","neon","station","train","bridge","river","harbor","window","rooftop","alley","rain","shadow","light","memory"],ADV:["softly","slowly","quietly","suddenly","gently","clearly","nearby","always"],PREP:["in","on","at","by","with","from","to","under","over","near","within","between","across","along","behind","through"],VERB:["glows","drifts","shines","lingers","echoes","rises","falls","breathes","quivers","hums","flickers","gathers","fades","returns"],GLYPHS:"cityharborneonmetro"},FR:{DET:["le","la","les","un","une","ce","cette","mon","ton","notre"],ADJ:["silencieux","lumineux","doux","humide","ancien","neuf","rouge","bleu","souple","froid","chaud","brillant","sombre"],NOUN:["rue","enseigne","néon","gare","train","pont","rivière","port","fenêtre","toit","ruelle","pluie","ombre","lumière","mémoire"],ADV:["doucement","lentement","silencieusement","soudain","clairement","toujours","tout_pres"],PREP:["dans","sur","à","par","avec","de","vers","sous","près","entre","a_travers","le_long_de","derrière"],VERB:["brille","dérive","luit","demeure","résonne","monte","tombe","respire","tremble","bourdonne","vacille","rassemble","revient"],GLYPHS:"memoireeclatneonruelle"},ZH:{DET:["这","那","我的","你的","我们的","这座","那条"],ADJ:["安静的","昏黄的","潮湿的","旧旧的","崭新的","红色的","蓝色的","柔软的","冰冷的","温热的","明亮的","模糊的"],NOUN:["巷子","路口","霓虹","地铁","车站","天桥","港口","码头","玻璃","窗户","屋顶","雨","影子","灯光","记忆"],ADV:["安静地","慢慢地","悄悄","忽然","清楚地","一直","在旁边"],PREP:["在","向","与","从","到","里","上","下","旁边","之间","沿着","经过","对面"],VERB:["发光","闪烁","滴落","回响","流淌","停住","靠近","远去","漂浮","聚拢","散开","延伸","照亮","隐藏"],GLYPHS:"城夜雨路口霓虹港口码头灯影记忆"},JA:{DET:["この","その","あの","私の","君の","駅前の","路地裏の"],ADJ:["静かな","濡れた","古びた","新しい","赤い","青い","柔らかな","冷たい","あたたかな","眩しい","薄暗い"],NOUN:["路地","看板","ネオン","駅","電車","高架","川","港","窓","屋上","雨","影","光","記憶"],ADV:["静かに","ゆっくり","ひっそり","突然","はっきり","いつも","近くで"],PREP:["が","を","に","で","へ","と","から","まで","の","は"],VERB:["光る","滲む","揺れる","漂う","響く","昇る","沈む","集まる","散る","灯る","震える","流れる","残る"],GLYPHS:"東都心駅改札高架灯影光影街巷"},KO:{DET:["이","그","저","나의","너의","우리의"],ADJ:["조용한","밝은","부드러운","축축한","오래된","새로운","빨간","파란","따뜻한","차가운","어두운","반짝이는"],NOUN:["골목","표지판","네온","역","기차","다리","강","항구","창문","옥상","비","그림자","빛","기억"],ADV:["조용히","천천히","살짝","갑자기","분명히","항상","가까이"],PREP:["이","가","을","를","에","에서","와","과","으로","부터","까지","은","는"],VERB:["빛나다","흐르다","떨리다","울리다","떠다니다","모이다","흩어지다","남다","스며들다","반짝이다"],GLYPHS:"골목창문비빛"}};
let determiners=[],adjectives=[],singularNouns=[],adverbs=[],particles=[],verbs3s=[],extraPoeticWords=[],words=[];
let DET_SET,ADJ_SET,NOUN_SET,ADV_SET,PREP_SET,V3_SET;
const POS={DET:"DET",ADJ:"ADJ",NOUN:"NOUN",VERB3S:"VERB3S",ADV:"ADV",PREP:"PREP",OTHER:"OTHER"};
const setFrom=arr=>new Set(arr.map(w=>w)), randomFrom=arr=>arr[floor(random(arr.length))];
class Magnet{constructor(pos,val,ang=0){this.pos=pos.copy();this.target=pos.copy();this.vel=createVector(0,0);this.ang=ang;this.angTarget=ang;this.angVel=0;this.val=String(val||"");this.col=252;this.scaler=typeof scaler!=="undefined"?scaler:1;this.paddingX=10*this.scaler;this.paddingY=7*this.scaler;this.home=pos.copy();this.isInPoem=false;this.displaySuffix="";this.displayOverride="";this.updateDimensions()}currentSurface(){return (this.displayOverride||this.val||"").replace(/[。.]$/,"")}getDisplayText(){return (this.displayOverride||this.val||"").replace(/[。.]$/,"")+(this.displaySuffix||"")}updateDimensions(){const fs=18*this.scaler;push();textSize(fs);textStyle(BOLD);textAlign(CENTER,CENTER);const w=textWidth(this.getDisplayText())+this.paddingX*2;const h=fs*1.45+this.paddingY*2;pop();this.dim=createVector(max(28*this.scaler,w),max(24*this.scaler,h))}setTarget(x,y,ang=null){this.target.set(x,y);if(ang!==null)this.angTarget=ang}update(){let ax=(this.target.x-this.pos.x)*SPRING_K-this.vel.x*DAMPING, ay=(this.target.y-this.pos.y)*SPRING_K-this.vel.y*DAMPING;this.vel.x+=ax;this.vel.y+=ay;if(abs(this.vel.x)<V_EPS&&abs(this.target.x-this.pos.x)<V_EPS){this.vel.x=0;this.pos.x=this.target.x}else this.pos.x+=this.vel.x;if(abs(this.vel.y)<V_EPS&&abs(this.target.y-this.pos.y)<V_EPS){this.vel.y=0;this.pos.y=this.target.y}else this.pos.y+=this.vel.y;let aw=(this.angTarget-this.ang)*ANG_K-this.angVel*ANG_DAMP;this.angVel+=aw;if(abs(this.angVel)<W_EPS&&abs(this.angTarget-this.ang)<W_EPS){this.angVel=0;this.ang=this.angTarget}else this.ang+=this.angVel;if(!this.isInPoem){const dy=this.pos.y, ay2=abs(dy); if(ay2<centerBandPx){const dir=(dy>=0)?1:-1;this.pos.y+=dir*(centerBandPx-ay2)*CENTER_SOFT_PUSH;this.target.y=this.pos.y;}}}contains(px,py){const dx=px-this.pos.x,dy=py-this.pos.y,s=sin(this.ang),c=cos(this.ang);const lx=dx*c+dy*s,ly=-dx*s+dy*c;return (abs(lx)<=this.dim.x/2&&abs(ly)<=this.dim.y/2)}overlaps(o){if(o===this)return false;return (abs(this.pos.x-o.pos.x)<(this.dim.x+o.dim.x)/2&&abs(this.pos.y-o.pos.y)<(this.dim.y+o.dim.y)/2)}show(){const txt=this.getDisplayText(),r=10*this.scaler;push();translate(this.pos.x,this.pos.y);rotate(this.ang);let alphaBoost=255;if(!this.isInPoem&&abs(this.pos.y)<centerBandPx+20){const t=constrain(1-(centerBandPx-abs(this.pos.y))/centerBandPx,0,1);alphaBoost=lerp(120,255,t)}noStroke();fill(0, Math.min(70, alphaBoost*.3));rectMode(CENTER);rect(3*this.scaler,4*this.scaler,this.dim.x,this.dim.y,r);stroke(40,90);strokeWeight(1.2*this.scaler);fill(this.col,alphaBoost);rect(0,0,this.dim.x,this.dim.y,r);stroke(0,30);noFill();rect(0,0,this.dim.x-6*this.scaler,this.dim.y-6*this.scaler,r*.8);noStroke();fill(255,90);const glossH=Math.max(6*this.scaler,this.dim.y*.20);rect(0,-this.dim.y/2+glossH/2+1*this.scaler,this.dim.x-6*this.scaler,glossH,r*.6);fill(20);noStroke();textAlign(CENTER,CENTER);textStyle(BOLD);textSize(18*this.scaler);text(txt,0,-.5*this.scaler);pop()}};
function makeBackground(activeGlyphs="東都心夜雨路地港口仓库霓虹駅改札高架灯影光影街巷记忆梧桐골목창문비빛memoireeclatneonharbor"){bg=createGraphics(width,height);bg.noSmooth();bg.background(246);bg.fill(0,30);bg.noStroke();bg.textAlign(CENTER,CENTER);const cell=max(10,floor(min(width,height)/60));bg.textSize(cell*.85);for(let y=cell/2;y<bg.height;y+=cell){for(let x=cell/2;x<bg.width;x+=cell){const ch=pickGlyph(activeGlyphs);const jx=random(-.2*cell,.2*cell),jy=random(-.2*cell,.2*cell);bg.fill(0,random(15,45));bg.text(ch,x+jx,y+jy)}}bg.stroke(0,12);for(let y=0;y<bg.height;y+=2){bg.line(0,y,bg.width,y)}}
function pickGlyph(pool){if(random()<.12){const latin=["city","harbor","metro","ruelle","neon","빛","雨","夜"];return random(latin)} const i=floor(random(pool.length));return pool.charAt(i)}
function rebuildPOSets(){DET_SET=setFrom(determiners);ADJ_SET=setFrom(adjectives);NOUN_SET=setFrom(singularNouns);ADV_SET=setFrom(adverbs);PREP_SET=setFrom(particles);V3_SET=setFrom(verbs3s)}
function posTag(word){if(DET_SET.has(word))return POS.DET;if(ADJ_SET.has(word))return POS.ADJ;if(NOUN_SET.has(word))return POS.NOUN;if(ADV_SET.has(word))return POS.ADV;if(PREP_SET.has(word))return POS.PREP;if(V3_SET.has(word))return POS.VERB3S;return POS.OTHER}
function activeLangsList(n){return LANG_ORDER.slice(0,constrain(n,1,5))}
function rebuildLexicon(n){const langs=activeLangsList(n);determiners=[].concat(...langs.map(L=>LEX[L].DET));adjectives=[].concat(...langs.map(L=>LEX[L].ADJ));singularNouns=[].concat(...langs.map(L=>LEX[L].NOUN));adverbs=[].concat(...langs.map(L=>LEX[L].ADV));particles=[].concat(...langs.map(L=>LEX[L].PREP));verbs3s=[].concat(...langs.map(L=>LEX[L].VERB));extraPoeticWords=["afterglow","echo","残響","霧","灯影","빛","光","memoire"];words=Array.from(new Set([...determiners,...adjectives,...singularNouns,...adverbs,...particles,...verbs3s,...extraPoeticWords]));rebuildPOSets();let glyphs=langs.map(L=>LEX[L].GLYPHS).join(""); makeBackground(glyphs.length?glyphs:undefined)}
function langsHuman(n){return activeLangsList(n).join("+")}
const TEMPLATES_8=[["DET","ADJ","NOUN","PREP","ADV","NOUN","PREP","VERB3S"],["DET","NOUN","PREP","ADJ","NOUN","PREP","ADV","VERB3S"],["NOUN","PREP","DET","ADJ","NOUN","PREP","ADV","VERB3S"],["DET","ADJ","NOUN","PREP","ADV","NOUN","PREP","VERB3S"]];
function pickFromPOS(tag){switch(tag){case"DET":return randomFrom(determiners);case"ADJ":return randomFrom(adjectives);case"NOUN":return randomFrom(singularNouns);case"VERB3S":return randomFrom(verbs3s);case"ADV":return randomFrom(adverbs);case"PREP":return randomFrom(particles);default:return ""}}
function chooseEnglishArticleFor(s){const ch=String(s||"").trim().charAt(0).toLowerCase();return "aeiou".includes(ch)?"an":"a"}
function makeEightWordPoem(){for(let m of magnets){if(m.isInPoem){m.isInPoem=false;m.displaySuffix="";m.displayOverride="";const tilt=random(-PI/32,PI/32);m.setTarget(m.home.x,m.home.y,tilt)}}const template=randomFrom(TEMPLATES_8);let chosenWords=template.map(tag=>pickFromPOS(tag));for(let i=0;i<template.length;i++){if(template[i]==="NOUN"&&i>0&&template[i-1]==="NOUN"&&chosenWords[i-1]===chosenWords[i]){let n=pickFromPOS("NOUN");for(let j=0;j<6&&n===chosenWords[i-1];j++)n=pickFromPOS("NOUN");chosenWords[i]=n}}for(let i=0;i<template.length;i++){if(template[i]==="DET"){const det=chosenWords[i];if(det==="a"||det==="an"){let look="";for(let j=i+1;j<template.length;j++){if(template[j]==="ADJ"||template[j]==="NOUN"){look=chosenWords[j];break}}chosenWords[i]=chooseEnglishArticleFor(look)}}}const chosenMagnets=chosenWords.map(w=>findMagnetByWord(w)).filter(Boolean); if(chosenMagnets.length!==chosenWords.length) return;chosenMagnets.forEach(m=>{m.displaySuffix="";m.displayOverride="";m.updateDimensions()});const last=chosenMagnets[chosenMagnets.length-1], lastSurface=last.getDisplayText(); last.displaySuffix=/[A-Za-z]/.test(lastSurface)?".":"。"; chosenMagnets.forEach(m=>m.updateDimensions());const gap=12*scaler; const totalW=chosenMagnets.reduce((s,m)=>s+m.dim.x,0)+gap*(chosenMagnets.length-1); let x=-totalW/2; const y=0;for(let m of magnets) m.isInPoem=false;for(let m of chosenMagnets){m.isInPoem=true;m.setTarget(x+m.dim.x/2,y,0);x+=m.dim.x+gap;}}
function findMagnetByWord(word){return magnets.find(m=>m.val===String(word))}
function shufflePoem(){makeEightWordPoem();saveMagnets(magnets)}
function makeMagnets(){magnets=[];for(let w of words){let pos=createVector(0,0);do{ pos.x=random(-.48*width,.48*width); pos.y=random(-.48*height,.48*height);} while (abs(pos.y)<centerBandPx+30 || abs(pos.x)<0.12*width);const ang=random(-PI/32,PI/32); magnets.push(new Magnet(pos,w,ang));}}
function spreadMagnets(){magnets.sort((a,b)=>(a.pos.x-b.pos.x));for(let m of magnets){for(let o of magnets){if(m.overlaps(o)&&m!=o){while((m.pos.x-m.dim.x/2)<(o.pos.x+o.dim.x/2)){m.pos.x+=1;o.pos.x-=1} m.target.x=m.pos.x;o.target.x=o.pos.x}}}}
function initHomesFromCurrentPos(){for(let m of magnets){m.home=m.pos.copy();m.setTarget(m.pos.x,m.pos.y,m.ang);m.isInPoem=false}}
function drawButtonsUI(){push();noStroke();fill(255,240);rect(UI.shuffle.x,UI.shuffle.y,UI.shuffle.w,UI.shuffle.h,8);rect(UI.reset.x,UI.reset.y,UI.reset.w,UI.reset.h,8);fill(0);textAlign(LEFT,CENTER);textSize(14);text(UI.shuffle.label,UI.shuffle.x+10,UI.shuffle.y+UI.shuffle.h/2+1);text(UI.reset.label,UI.reset.x+10,UI.reset.y+UI.reset.h/2+1);pop()}
function hit(r,x,y){return (x>=r.x&&x<=r.x+r.w&&y>=r.y&&y<=r.y+r.h)}
function setup(){createCanvas(windowWidth,windowHeight); scaler=height/628; noSmooth(); recomputeCenterBand();langSlider=createSlider(1,5,activeLangCount,1); langSlider.position(220,12); langSlider.style('width','220px'); langSlider.input(onSliderChange);langLabel=createDiv(""); langLabel.position(450,6); langLabel.style('font-size','14px'); langLabel.style('background','rgba(255,255,255,.85)'); langLabel.style('padding','6px 10px'); langLabel.style('border-radius','8px'); updateLangLabel();rebuildLexicon(activeLangCount);const saved=loadMagnets(); if(saved===null){loadData([]); makeMagnets(); for(let i=0;i<10;i++) spreadMagnets(); initHomesFromCurrentPos(); makeEightWordPoem(); saveMagnets(magnets);} else{ try{loadData(saved); if(!magnets.some(m=>m.isInPoem)) makeEightWordPoem();}catch(e){clearMagnets(); loadData([]); makeMagnets(); initHomesFromCurrentPos(); makeEightWordPoem();}} textSize(16*scaler);}
function updateLangLabel(){langLabel.html("Languages: "+activeLangCount+" ("+langsHuman(activeLangCount)+")")}
function onSliderChange(){const n=langSlider.value(); if(n===activeLangCount) return; activeLangCount=n; updateLangLabel(); rebuildLexicon(activeLangCount); makeMagnets(); initHomesFromCurrentPos(); makeEightWordPoem(); saveMagnets(magnets);}
function draw(){background(246); image(bg,0,0); push(); translate(width/2,height/2); for(let m of magnets){if(m!==selected)m.update(); m.show();} pop(); drawButtonsUI();}
function mousePressed(){dragMoved=false; if(hit(UI.shuffle,mouseX,mouseY)){shufflePoem();return} if(hit(UI.reset,mouseX,mouseY)){resetEverything();return} const mx=mouseX-width/2,my=mouseY-height/2; for(let m of magnets){if(m.contains(mx,my)){offset=createVector(m.pos.x-mx,m.pos.y-my); selected=m;m.col=252;m.vel.set(0,0);m.angVel=0;break}}}
function mouseDragged(){if(selected){const mx=mouseX-width/2,my=mouseY-height/2; selected.pos.x=mx+offset.x; selected.pos.y=my+offset.y; selected.target.set(selected.pos.x,selected.pos.y); dragMoved=true}}
function mouseReleased(){for(let m of magnets){if(selected&&selected.overlaps(m)&&selected!=m){if(selected.pos.x>m.pos.x){while((selected.pos.x-selected.dim.x/2)<(m.pos.x+m.dim.x/2))selected.pos.x+=1}else{while((selected.pos.x+selected.dim.x/2)>(m.pos.x-m.dim.x/2))selected.pos.x-=1} selected.pos.y=m.pos.y; m.angTarget=0}} if(selected){if(!dragMoved&&selected.isInPoem){swapWithinSamePOS(selected); saveMagnets(magnets)} selected.target.set(selected.pos.x,selected.pos.y); if(!selected.isInPoem) selected.home=selected.pos.copy(); selected=null} saveMagnets(magnets)}
function keyPressed(){if(key===' '||key==='S'||key==='s'){shufflePoem();return false}}
function swapWithinSamePOS(mag){const tag=posTag(mag.currentSurface()); let pool=[]; switch(tag){case POS.DET:pool=determiners;break;case POS.ADJ:pool=adjectives;break;case POS.NOUN:pool=singularNouns;break;case POS.VERB3S:pool=verbs3s;break;case POS.ADV:pool=adverbs;break;case POS.PREP:pool=particles;break;default:pool=[]} if(!pool.length) return; const cur=mag.currentSurface(); let cand=randomFrom(pool),guard=0; while(cand===cur&&guard<16){cand=randomFrom(pool);guard++} const suf=mag.displaySuffix; mag.displayOverride=cand; mag.displaySuffix=suf; mag.updateDimensions()}
function loadData(data){scaler=height/628; magnets=[]; for(let m of (Array.isArray(data)?data:[])){const msc=(typeof m.scaler==='number'&&isFinite(m.scaler)&&m.scaler>0)?m.scaler:1; let x=(m.pos&&m.pos.x!=null)?m.pos.x*scaler/msc:0, y=(m.pos&&m.pos.y!=null)?m.pos.y*scaler/msc:0, val=(m.val!=null)?m.val:"", ang=m.ang||0; let mm=new Magnet(createVector(x,y),val,ang); mm.displaySuffix=m.displaySuffix||""; mm.displayOverride=m.displayOverride||""; if(m.home&&typeof m.home.x==='number'&&typeof m.home.y==='number'){mm.home=createVector(m.home.x*scaler/msc,m.home.y*scaler/msc)} else{mm.home=mm.pos.copy()} mm.isInPoem=!!m.isInPoem; mm.setTarget(mm.pos.x,mm.pos.y,mm.ang); mm.updateDimensions(); magnets.push(mm)}}
function resetEverything(){clearMagnets(); rebuildLexicon(activeLangCount); loadData([]); makeMagnets(); initHomesFromCurrentPos(); makeEightWordPoem();}
function windowResized(){resizeCanvas(windowWidth,windowHeight); scaler=height/628; recomputeCenterBand(); rebuildLexicon(activeLangCount); const saved=loadMagnets(); if(saved) loadData(saved)}
</script>
</body></html>
